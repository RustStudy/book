<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title></title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="{% block description %}{% endblock %}">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <!-- Font Awesome -->
        <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="http://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body>
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="introduction.html"><strong>1.</strong> 介绍</a></li><li><ul class="section"><li><a href="installation.html"><strong>1.1.</strong> 安装</a></li><li><a href="hello-world.html"><strong>1.2.</strong> Hello, World!</a></li><li><a href="design.html"><strong>1.3.</strong> Rust的设计</a></li></ul></li><li><a href="tutorial.html"><strong>2.</strong> Tutorial</a></li><li><a href="primitive-rust.html"><strong>3.</strong> Rust基础</a></li><li><ul class="section"><li><a href="variable-bindings.html"><strong>3.1.</strong> Variable Bindings</a></li><li><a href="functions.html"><strong>3.2.</strong> Functions</a></li><li><a href="primitive-types.html"><strong>3.3.</strong> Primitive Types</a></li><li><a href="comments.html"><strong>3.4.</strong> Comments</a></li><li><a href="if.html"><strong>3.5.</strong> `if`</a></li><li><a href="loops.html"><strong>3.6.</strong> Loops</a></li></ul></li><li><a href="ownership-and-borrowing.html"><strong>4.</strong> Ownership & borrowing</a></li><li><ul class="section"><li><a href="ownership.html"><strong>4.1.</strong> Ownership</a></li><li><a href="references-and-borrowing.html"><strong>4.2.</strong> References & Borrowing</a></li><li><a href="lifetimes.html"><strong>4.3.</strong> Lifetimes</a></li></ul></li><li><a href="basic-data-types.html"><strong>5.</strong> Basic Data Types</a></li><li><ul class="section"><li><a href="structs.html"><strong>5.1.</strong> Structs</a></li><li><a href="enums.html"><strong>5.2.</strong> Enums</a></li></ul></li><li><a href="crates-and-modules.html"><strong>6.</strong> Crates & Modules</a></li><li><a href="error-handling.html"><strong>7.</strong> Error Handling</a></li><li><a href="basic-collections.html"><strong>8.</strong> Basic Collections</a></li><li><ul class="section"><li><a href="vectors.html"><strong>8.1.</strong> Vectors</a></li><li><a href="strings.html"><strong>8.2.</strong> Strings</a></li><li><a href="hashmap.html"><strong>8.3.</strong> `HashMap<K, V>`</a></li></ul></li><li><a href="traits.html"><strong>9.</strong> Traits</a></li><li><a href="closures.html"><strong>10.</strong> Closures</a></li><li><a href="iterators.html"><strong>11.</strong> Iterators</a></li><li><a href="io.html"><strong>12.</strong> I/O</a></li><li><ul class="section"><li><a href="read-and-write.html"><strong>12.1.</strong> `Read` & `Write`</a></li><li><a href="fs.html"><strong>12.2.</strong> `std::fs`</a></li><li><a href="path.html"><strong>12.3.</strong> `std::path`</a></li><li><a href="env.html"><strong>12.4.</strong> `std::env`</a></li></ul></li><li><a href="testing.html"><strong>13.</strong> Testing</a></li><li><a href="smart-pointers.html"><strong>14.</strong> Smart Pointers</a></li><li><ul class="section"><li><a href="deref.html"><strong>14.1.</strong> `Deref`</a></li><li><a href="deref-coercions.html"><strong>14.2.</strong> `Deref` coercions</a></li><li><a href="box.html"><strong>14.3.</strong> `Box<T>`</a></li><li><a href="rc.html"><strong>14.4.</strong> `Rc<T>`</a></li></ul></li><li><a href="concurrency.html"><strong>15.</strong> Concurrency</a></li><li><ul class="section"><li><a href="threads.html"><strong>15.1.</strong> Threads</a></li><li><a href="send-and-sync.html"><strong>15.2.</strong> `Send` & `Sync`</a></li><li><a href="arc.html"><strong>15.3.</strong> `Arc<T>`</a></li><li><a href="mutex.html"><strong>15.4.</strong> `Mutex<T>`</a></li><li><a href="channels.html"><strong>15.5.</strong> `Channels`</a></li></ul></li><li><a href="unsafe-rust.html"><strong>16.</strong> Unsafe Rust</a></li><li><ul class="section"><li><a href="raw-pointers.html" class="active"><strong>16.1.</strong> Raw Pointers</a></li><li><a href="transmute.html"><strong>16.2.</strong> transmute</a></li></ul></li><li><a href="ffi.html"><strong>17.</strong> FFI</a></li><li><ul class="section"><li><a href="conditional-compilation.html"><strong>17.1.</strong> Conditional Compilation</a></li><li><a href="bindings-to-c.html"><strong>17.2.</strong> Bindings to C</a></li><li><a href="using-rust-from-other-languages.html"><strong>17.3.</strong> Using Rust from Other Languages</a></li><li><a href="static.html"><strong>17.4.</strong> `static`</a></li></ul></li><li><a href="cargo.html"><strong>18.</strong> Cargo</a></li><li><ul class="section"><li><a href="cratesio.html"><strong>18.1.</strong> Crates.io</a></li></ul></li><li><a href="advanced-type-system-features.html"><strong>19.</strong> Advanced Type System Features</a></li><li><ul class="section"><li><a href="associated-types.html"><strong>19.1.</strong> Associated Types</a></li><li><a href="trait-objects.html"><strong>19.2.</strong> Trait Objects</a></li><li><a href="ufcs.html"><strong>19.3.</strong> UFCS</a></li><li><a href="coherence.html"><strong>19.4.</strong> Coherence</a></li></ul></li><li><a href="interior-mutability.html"><strong>20.</strong> Interior mutability</a></li><li><ul class="section"><li><a href="cell.html"><strong>20.1.</strong> `Cell<T>`</a></li><li><a href="refcell.html"><strong>20.2.</strong> `RefCell<T>`</a></li></ul></li><li><a href="macros.html"><strong>21.</strong> Macros</a></li><li><a href="nightly-rust.html"><strong>22.</strong> Nightly Rust</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <h1>Raw Pointers</h1>
<p>Rust has a number of different smart pointer types in its standard library, but
there are two types that are extra-special. Much of Rust’s safety comes from
compile-time checks, but raw pointers don’t have such guarantees, and are
<a href="unsafe.html">unsafe</a> to use.</p>
<p><code>*const T</code> and <code>*mut T</code> are called ‘raw pointers’ in Rust. Sometimes, when
writing certain kinds of libraries, you’ll need to get around Rust’s safety
guarantees for some reason. In this case, you can use raw pointers to implement
your library, while exposing a safe interface for your users. For example, <code>*</code>
pointers are allowed to alias, allowing them to be used to write
shared-ownership types, and even thread-safe shared memory types (the <code>Rc&lt;T&gt;</code>
and <code>Arc&lt;T&gt;</code> types are both implemented entirely in Rust).</p>
<p>Here are some things to remember about raw pointers that are different than
other pointer types. They:</p>
<ul>
<li>are not guaranteed to point to valid memory and are not even
guaranteed to be non-null (unlike both <code>Box</code> and <code>&amp;</code>);</li>
<li>do not have any automatic clean-up, unlike <code>Box</code>, and so require
manual resource management;</li>
<li>are plain-old-data, that is, they don't move ownership, again unlike
<code>Box</code>, hence the Rust compiler cannot protect against bugs like
use-after-free;</li>
<li>lack any form of lifetimes, unlike <code>&amp;</code>, and so the compiler cannot
reason about dangling pointers; and</li>
<li>have no guarantees about aliasing or mutability other than mutation
not being allowed directly through a <code>*const T</code>.</li>
</ul>
<h1>Basics</h1>
<p>Creating a raw pointer is perfectly safe:</p>
<pre><code class="language-rust">let x = 5;
let raw = &amp;x as *const i32;

let mut y = 10;
let raw_mut = &amp;mut y as *mut i32;
</code></pre>
<p>However, dereferencing one is not. This won’t work:</p>
<pre><code class="language-rust,ignore">let x = 5;
let raw = &amp;x as *const i32;

println!(&quot;raw points at {}&quot;, *raw);
</code></pre>
<p>It gives this error:</p>
<pre><code class="language-text">error: dereference of raw pointer requires unsafe function or block [E0133]
     println!(&quot;raw points at {}&quot;, *raw);
                                  ^~~~
</code></pre>
<p>When you dereference a raw pointer, you’re taking responsibility that it’s not
pointing somewhere that would be incorrect. As such, you need <code>unsafe</code>:</p>
<pre><code class="language-rust">let x = 5;
let raw = &amp;x as *const i32;

let points_at = unsafe { *raw };

println!(&quot;raw points at {}&quot;, points_at);
</code></pre>
<p>For more operations on raw pointers, see <a href="../std/primitive.pointer.html">their API documentation</a>.</p>
<h1>FFI</h1>
<p>Raw pointers are useful for FFI: Rust’s <code>*const T</code> and <code>*mut T</code> are similar to
C’s <code>const T*</code> and <code>T*</code>, respectively. For more about this use, consult the
<a href="ffi.html">FFI chapter</a>.</p>
<h1>References and raw pointers</h1>
<p>At runtime, a raw pointer <code>*</code> and a reference pointing to the same piece of
data have an identical representation. In fact, an <code>&amp;T</code> reference will
implicitly coerce to an <code>*const T</code> raw pointer in safe code and similarly for
the <code>mut</code> variants (both coercions can be performed explicitly with,
respectively, <code>value as *const T</code> and <code>value as *mut T</code>).</p>
<p>Going the opposite direction, from <code>*const</code> to a reference <code>&amp;</code>, is not safe. A
<code>&amp;T</code> is always valid, and so, at a minimum, the raw pointer <code>*const T</code> has to
point to a valid instance of type <code>T</code>. Furthermore, the resulting pointer must
satisfy the aliasing and mutability laws of references. The compiler assumes
these properties are true for any references, no matter how they are created,
and so any conversion from raw pointers is asserting that they hold. The
programmer <em>must</em> guarantee this.</p>
<p>The recommended method for the conversion is:</p>
<pre><code class="language-rust">// explicit cast
let i: u32 = 1;
let p_imm: *const u32 = &amp;i as *const u32;

// implicit coercion
let mut m: u32 = 2;
let p_mut: *mut u32 = &amp;mut m;

unsafe {
    let ref_imm: &amp;u32 = &amp;*p_imm;
    let ref_mut: &amp;mut u32 = &amp;mut *p_mut;
}
</code></pre>
<p>The <code>&amp;*x</code> dereferencing style is preferred to using a <code>transmute</code>. The latter
is far more powerful than necessary, and the more restricted operation is
harder to use incorrectly; for example, it requires that <code>x</code> is a pointer
(unlike <code>transmute</code>).</p>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a href="unsafe-rust.html" class="mobile-nav-chapters previous">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="transmute.html" class="mobile-nav-chapters next">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="unsafe-rust.html" class="nav-chapters previous">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="transmute.html" class="nav-chapters next">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
