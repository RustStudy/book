<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title></title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="{% block description %}{% endblock %}">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <!-- Font Awesome -->
        <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="http://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body>
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="introduction.html"><strong>1.</strong> 介绍</a></li><li><ul class="section"><li><a href="installation.html"><strong>1.1.</strong> 安装</a></li><li><a href="hello-world.html"><strong>1.2.</strong> Hello, World!</a></li><li><a href="design.html"><strong>1.3.</strong> Rust的设计</a></li></ul></li><li><a href="tutorial.html"><strong>2.</strong> Tutorial</a></li><li><a href="primitive-rust.html"><strong>3.</strong> Rust基础</a></li><li><ul class="section"><li><a href="variable-bindings.html"><strong>3.1.</strong> 变量绑定</a></li><li><a href="functions.html" class="active"><strong>3.2.</strong> Functions</a></li><li><a href="primitive-types.html"><strong>3.3.</strong> Primitive Types</a></li><li><a href="comments.html"><strong>3.4.</strong> Comments</a></li><li><a href="if.html"><strong>3.5.</strong> `if`</a></li><li><a href="loops.html"><strong>3.6.</strong> Loops</a></li></ul></li><li><a href="ownership-and-borrowing.html"><strong>4.</strong> Ownership & borrowing</a></li><li><ul class="section"><li><a href="ownership.html"><strong>4.1.</strong> Ownership</a></li><li><a href="references-and-borrowing.html"><strong>4.2.</strong> References & Borrowing</a></li><li><a href="lifetimes.html"><strong>4.3.</strong> Lifetimes</a></li></ul></li><li><a href="basic-data-types.html"><strong>5.</strong> Basic Data Types</a></li><li><ul class="section"><li><a href="structs.html"><strong>5.1.</strong> Structs</a></li><li><a href="enums.html"><strong>5.2.</strong> Enums</a></li></ul></li><li><a href="crates-and-modules.html"><strong>6.</strong> Crates & Modules</a></li><li><a href="error-handling.html"><strong>7.</strong> Error Handling</a></li><li><a href="basic-collections.html"><strong>8.</strong> Basic Collections</a></li><li><ul class="section"><li><a href="vectors.html"><strong>8.1.</strong> Vectors</a></li><li><a href="strings.html"><strong>8.2.</strong> Strings</a></li><li><a href="hashmap.html"><strong>8.3.</strong> `HashMap<K, V>`</a></li></ul></li><li><a href="traits.html"><strong>9.</strong> Traits</a></li><li><a href="closures.html"><strong>10.</strong> Closures</a></li><li><a href="iterators.html"><strong>11.</strong> Iterators</a></li><li><a href="io.html"><strong>12.</strong> I/O</a></li><li><ul class="section"><li><a href="read-and-write.html"><strong>12.1.</strong> `Read` & `Write`</a></li><li><a href="fs.html"><strong>12.2.</strong> `std::fs`</a></li><li><a href="path.html"><strong>12.3.</strong> `std::path`</a></li><li><a href="env.html"><strong>12.4.</strong> `std::env`</a></li></ul></li><li><a href="testing.html"><strong>13.</strong> Testing</a></li><li><a href="smart-pointers.html"><strong>14.</strong> Smart Pointers</a></li><li><ul class="section"><li><a href="deref.html"><strong>14.1.</strong> `Deref`</a></li><li><a href="deref-coercions.html"><strong>14.2.</strong> `Deref` coercions</a></li><li><a href="box.html"><strong>14.3.</strong> `Box<T>`</a></li><li><a href="rc.html"><strong>14.4.</strong> `Rc<T>`</a></li></ul></li><li><a href="concurrency.html"><strong>15.</strong> Concurrency</a></li><li><ul class="section"><li><a href="threads.html"><strong>15.1.</strong> Threads</a></li><li><a href="send-and-sync.html"><strong>15.2.</strong> `Send` & `Sync`</a></li><li><a href="arc.html"><strong>15.3.</strong> `Arc<T>`</a></li><li><a href="mutex.html"><strong>15.4.</strong> `Mutex<T>`</a></li><li><a href="channels.html"><strong>15.5.</strong> `Channels`</a></li></ul></li><li><a href="unsafe-rust.html"><strong>16.</strong> Unsafe Rust</a></li><li><ul class="section"><li><a href="raw-pointers.html"><strong>16.1.</strong> Raw Pointers</a></li><li><a href="transmute.html"><strong>16.2.</strong> transmute</a></li></ul></li><li><a href="ffi.html"><strong>17.</strong> FFI</a></li><li><ul class="section"><li><a href="conditional-compilation.html"><strong>17.1.</strong> Conditional Compilation</a></li><li><a href="bindings-to-c.html"><strong>17.2.</strong> Bindings to C</a></li><li><a href="using-rust-from-other-languages.html"><strong>17.3.</strong> Using Rust from Other Languages</a></li><li><a href="static.html"><strong>17.4.</strong> `static`</a></li></ul></li><li><a href="cargo.html"><strong>18.</strong> Cargo</a></li><li><ul class="section"><li><a href="cratesio.html"><strong>18.1.</strong> Crates.io</a></li></ul></li><li><a href="advanced-type-system-features.html"><strong>19.</strong> Advanced Type System Features</a></li><li><ul class="section"><li><a href="associated-types.html"><strong>19.1.</strong> Associated Types</a></li><li><a href="trait-objects.html"><strong>19.2.</strong> Trait Objects</a></li><li><a href="ufcs.html"><strong>19.3.</strong> UFCS</a></li><li><a href="coherence.html"><strong>19.4.</strong> Coherence</a></li></ul></li><li><a href="interior-mutability.html"><strong>20.</strong> Interior mutability</a></li><li><ul class="section"><li><a href="cell.html"><strong>20.1.</strong> `Cell<T>`</a></li><li><a href="refcell.html"><strong>20.2.</strong> `RefCell<T>`</a></li></ul></li><li><a href="macros.html"><strong>21.</strong> Macros</a></li><li><a href="nightly-rust.html"><strong>22.</strong> Nightly Rust</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <h1>Functions</h1>
<p>Functions are pervasive in Rust code. We’ve already seen the most important function, <code>main()</code>, in previous sections of the book:</p>
<pre><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre>
<p>We can declare new functions with the <code>fn</code> keyword:</p>
<pre><code class="language-rust">fn another_function() {
    println!(&quot;Another function.&quot;);
}
</code></pre>
<p>Rust code uses <code>snake_case</code> as a style for function names: all lower case, with underscores separating words.
(It also uses them for variable names, too.)
We can can call any function we’ve defined by using its name and some parentheses:</p>
<pre><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);

    another_function();
}

fn another_function() {
    println!(&quot;Another function.&quot;);
}
</code></pre>
<p>Let’s start a new project to explore functions.
Open a terminal, and navigate to the directory where you’d like to keep your projects.
From there, use Cargo to generate a new project:</p>
<pre><code class="language-bash">$ cargo new --bin functions
$ cd functions
</code></pre>
<p>Place the new example in <code>src/main.rs</code>, and run it:</p>
<pre><code class="language-bash">$ cargo run
   Compiling functions v0.1.0 (file:///home/steve/tmp/functions)
     Running `target/debug/functions`
Hello, world!
Another function.
</code></pre>
<p>As we can see, the lines execute in order: first, we print out our “Hello, world!” message, and then <code>another_function()</code> is called.
It then prints its message as well.</p>
<h2>Function Arguments</h2>
<p>Functions can also take arguments:</p>
<pre><code class="language-rust">fn main() {
    another_function(5);
}

fn another_function(x: i32) {
    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre>
<p>Let’s try running it:</p>
<pre><code class="language-bash">$ cargo run
   Compiling functions v0.1.0 (file:///home/steve/tmp/functions)
     Running `target/debug/functions`
The value of x is: 5
</code></pre>
<p>Let’s take a closer look at <code>another_function()</code>’s signature:</p>
<pre><code class="language-rust,ignore">fn another_function(x: i32) {
</code></pre>
<p>Declaring a function which takes a single argument looks like this:</p>
<pre><code class="language-text">fn NAME(PATTERN: TYPE) {
</code></pre>
<p>That’s right, patterns appear again.
Consider how the parameter declaration here looks like the <code>let</code> bindings we used earlier:</p>
<pre><code class="language-rust,ignore">let x: i32;
fn another_function(x: i32) {
</code></pre>
<p>There’s only one difference here: in function signatures, we <em>must</em> declare the type.
This is a deliberate decision; we find that requiring type annotations in functions means that you almost never need them anywhere else.</p>
<p>You can separate multiple arguments with a comma:</p>
<pre><code class="language-text">fn NAME(PATTERN, PATTERN, PATTERN, PATTERN...) {
</code></pre>
<p>Here’s a full example:</p>
<pre><code class="language-rust">fn main() {
    another_function(5, 6);
}

fn another_function(x: i32, y: i32) {
    println!(&quot;The value of x is: {}&quot;, x);
    println!(&quot;The value of y is: {}&quot;, y);
}
</code></pre>
<p>Let’s try it:</p>
<pre><code class="language-bash">$ cargo run
   Compiling functions v0.1.0 (file:///home/steve/tmp/functions)
     Running `target/debug/functions`
The value of x is: 5
The value of y is: 6
</code></pre>
<p>We could also create bindings, and pass them in as arguments:</p>
<pre><code class="language-rust">fn main() {
    let a = 5;
    let b = 6;

    another_function(a, b);
}

fn another_function(x: i32, y: i32) {
    println!(&quot;The value of x is: {}&quot;, x);
    println!(&quot;The value of y is: {}&quot;, y);
}
</code></pre>
<p>This has the same effect:</p>
<pre><code class="language-bash">$ cargo run
   Compiling functions v0.1.0 (file:///home/steve/tmp/functions)
     Running `target/debug/functions`
The value of x is: 5
The value of y is: 6
</code></pre>
<p>Note that our bindings are called <code>a</code> and <code>b</code>, yet inside of the function, we refer to them by the names in the signature, <code>x</code> and <code>y</code>.
Inside a function, only its parameters are in scope, so we need to use those names.
Bindings passed as parameters don’t need to have the same name as the arguments.</p>
<h2>Return values</h2>
<p>Functions can also return values back to the function that called them:</p>
<pre><code class="language-TEXT">fn NAME(PATTERN, PATTERN, PATTERN, PATTERN...) -&gt; TYPE {
</code></pre>
<p>We don’t name return values, but we do declare their type, after an arrow: <code>-&gt;</code>.
Here’s a sample program:</p>
<pre><code class="language-rust">fn main() {
    let x = five();

    println!(&quot;The value of x is: {}&quot;, x);
}

fn five() -&gt; i32 {
    5
}
</code></pre>
<p>Let’s try running it:</p>
<pre><code class="language-bash">$ cargo run
   Compiling functions v0.1.0 (file:///home/steve/tmp/functions)
     Running `target/debug/functions`
The value of x is: 5
</code></pre>
<p>Let’s examine this in more detail.
There are two important bits.
First, we can use the return value of a function to initialize a binding:</p>
<pre><code class="language-rust,ignore">let x = five();
</code></pre>
<p>Because <code>five()</code> returns a <code>5</code>, this is the same as:</p>
<pre><code class="language-rust">let x = 5;
</code></pre>
<p>The second interesting bit is <code>five()</code> itself:</p>
<pre><code class="language-rust">fn five() -&gt; i32 {
    5
}
</code></pre>
<p>We have no arguments, and our return type, <code>i32</code>.
However, the body of this function is a lonely <code>5</code>.
There’s a detail here that you may or may not have noticed: we’ve ended almost every line in our programs with a semicolon.
There’s no semicolon here, though.
Why not?</p>
<p>The answer to this question is:</p>
<blockquote>
<p>The return value of a function is the value of its final expression.</p>
</blockquote>
<p>We haven’t talked about expressions yet, so this definition doesn’t help a lot.
Let’s go over that now.</p>
<h2>Statements and Expressions</h2>
<p>Expressions are bits of code that evaluate to a value.
Consider some math operations, like this:</p>
<pre><code class="language-rust,ignore">5 + 6
</code></pre>
<p>We can evaluate this expression, and come up with a value: <code>11</code>.
In Rust, most bits of code are expressions.
For example, calling a function is an expression:</p>
<pre><code class="language-rust,ignore">foo(5)
</code></pre>
<p>The value is equal to whatever the return value of <code>foo()</code> is.</p>
<p>So why does this matter?
Well, not everything is an expression.
Some things are ‘statements’.
Expressions <em>compute</em> something, but statements <em>bind</em> or <em>do</em> something.
It’s a subtle difference.
We’ve already seen two kinds of statements: <code>let</code> statements, and <code>fn</code> declarations.</p>
<p>Because <code>let</code> is a statement, not an expression, you can’t assign it to another binding.
Here’s an example that doesn’t work:</p>
<pre><code class="language-rust,ignore">fn main() {
    let x = (let y = 6);
}
</code></pre>
<p>If we try to run this program, we’ll get an error:</p>
<pre><code class="language-bash">$ cargo run
   Compiling functions v0.1.0 (file:///home/steve/tmp/functions)
src/main.rs:2:14: 2:17 error: expected identifier, found keyword `let`
src/main.rs:2     let x = (let y = 6);
                           ^~~
src/main.rs:2:18: 2:19 error: expected one of `!`, `)`, `,`, `.`, `::`, `{`, or an operator, found `y`
src/main.rs:2     let x = (let y = 6);
                               ^
Could not compile `functions`.
</code></pre>
<p>We also cannot somehow assign a <code>fn</code> declaration to a binding, either.</p>
<p>So what’s this have to do with return values?
Well, <code>{}</code>, a ‘block’ that we used earlier to create new scopes, <em>is</em> an expression.
Let’s take a closer look at <code>{}</code>.
It looks like this:</p>
<pre><code class="language-text">{
    STATEMENT*
    EXPRESSION
}
</code></pre>
<p>The <code>*</code> there means ‘zero or more’, so we can have any number of statements followed by an expression.
Since blocks are expressions themselves, we can nest blocks inside of blocks.
And since they return a value, we can use them in <code>let</code> statements:</p>
<pre><code class="language-rust">fn main() {
    let x = 5;

    let y = {
        let z = 1;
        
        x + z + 5
    };

    println!(&quot;The value of y is: {}&quot;, y);
}
</code></pre>
<p>Let’s try running this program:</p>
<pre><code class="language-bash">   Compiling functions v0.1.0 (file:///home/steve/tmp/functions)
     Running `target/debug/functions`
The value of y is: 11
</code></pre>
<p>We’re now using a block to give us a value for <code>y</code>:</p>
<pre><code class="language-rust,ignore">let y = {

};
</code></pre>
<p>Since the block can contain statements, we create a new variable binding, <code>z</code>, and give it a value.
We then do some math for the final expression of the block:</p>
<pre><code class="language-rust,ignore">{
    let z = 1;

    x + z + 5
}
</code></pre>
<p><code>5 + 1 + 5</code> is <code>11</code>, and so the value of the entire block is <code>11</code>.
This gets substituted into our <code>let</code> statement for <code>y</code>:</p>
<pre><code class="language-rust,ignore">let y = 11;
</code></pre>
<p>Hence our output saying <code>y</code> is <code>11</code>.</p>
<p>Where else do we use blocks? As the body of functions!
They’re very similar:</p>
<pre><code class="language-rust">fn main() {
    let x = 5;

    let y = {
        x + 1
    };

    println!(&quot;The value of y is: {}&quot;, y);

    let y = plus_one(x);

    println!(&quot;The value of y is: {}&quot;, y);
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1
}
</code></pre>
<p>Running this gives:</p>
<pre><code class="language-bash">$ cargo run
   Compiling functions v0.1.0 (file:///home/steve/tmp/functions)
     Running `target/debug/functions`
The value of y is: 6
The value of y is: 6
</code></pre>
<p>In both cases, we use a block to produce a value.
In the first case, it’s assigning with <code>let</code>:</p>
<pre><code class="language-rust,ignore">let y = {
</code></pre>
<p>In the second, it’s the return value of the function:</p>
<pre><code class="language-rust,ignore">fn plus_one(x: i32) -&gt; i32 {
</code></pre>
<h3>Expression statements</h3>
<p>There’s one more detail about expressions and statements: a semicolon takes any expression, and turns it into a statement.
Let’s accidentally cause an error with <code>plus_one()</code>:</p>
<pre><code class="language-rust,ignore">fn main() {
    let x = plus_one(5);

    println!(&quot;The value of x is: {}&quot;, x);
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1;
}
</code></pre>
<p>Instead of an expression, <code>x + 1</code>, we’ve now turned it into a statement, <code>x + 1;</code>.</p>
<p>Running this gives an error:</p>
<pre><code class="language-bash">$ cargo run
   Compiling functions v0.1.0 (file:///home/steve/tmp/functions)
src/main.rs:7:1: 9:2 error: not all control paths return a value [E0269]
src/main.rs:7 fn plus_one(x: i32) -&gt; i32 {
src/main.rs:8     x + 1;
src/main.rs:9 }
src/main.rs:7:1: 9:2 help: run `rustc --explain E0269` to see a detailed explanation
src/main.rs:8:10: 8:11 help: consider removing this semicolon:
src/main.rs:8     x + 1;
                       ^
error: aborting due to previous error
Could not compile `functions`.
</code></pre>
<p>Rust has our back here: it even suggests removing the semicolon, which fixes the error.
But the main error message is the core of the issue: statements don’t evaluate to a value, yet we want to return an <code>i32</code>.</p>
<p>In practice, Rust programmers don’t often think about these rules at this
level. Usually, you have a semicolon at the end of most lines, and maybe not at
the end of blocks.</p>
<h2>Multiple return values</h2>
<p>Functions cannot directly return multiple values.
There’s a trick, however. Remember the <code>()</code>s we used when showing off complex bindings?</p>
<pre><code class="language-rust">fn main() {
    let (x, y) = (5, 6);
}
</code></pre>
<p>They form something called a ‘tuple’, one of Rust’s basic types.
A tuple is an anonymous collection of elements.
But since a tuple is a singular thing, we can use it as a way to return multiple values from functions:</p>
<pre><code class="language-rust">fn main() {
    let (x, y) = two_numbers();

    println!(&quot;The value of x is: {}&quot;, x);
    println!(&quot;The value of y is: {}&quot;, y);
}

fn two_numbers() -&gt; (i32, i32) {
    (5, 6)
}
</code></pre>
<p>Running this will show us the values:</p>
<pre><code class="language-bash">$ cargo run
   Compiling functions v0.1.0 (file:///home/steve/tmp/functions)
     Running `target/debug/functions`
The value of x is: 5
The value of y is: 6
</code></pre>
<p>There are two interesting changes here: assigning the return value of <code>two_numbers()</code> to <code>x</code> and <code>y</code>, and the declaration of <code>two_numbers()</code> itself.</p>
<p>Let’s look at the declaration first:</p>
<pre><code class="language-rust">fn two_numbers() -&gt; (i32, i32) {
    (5, 6)
}
</code></pre>
<p>The <code>(i32, i32)</code> should look familiar.
We saw it in <code>let</code> bindings earlier:</p>
<pre><code class="language-rust">let (x, y): (i32, i32) = (5, 6);
</code></pre>
<p>The <code>(i32, i32)</code> syntax says “a tuple with two <code>i32</code>s in it.”
The <code>(5, 6)</code> syntax creates a new one, with <code>5</code> and <code>6</code>.</p>
<p>This tuple is then returned, and assigned to <code>x</code> and <code>y</code>:</p>
<pre><code class="language-rust,ignore">let (x, y) = two_numbers();
</code></pre>
<p>See how all these bits fit together?</p>
<p>We call this behavior of <code>let</code> ‘destructuring’, because it takes the structure of the expression that comes after the <code>=</code> and takes it apart.</p>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a href="variable-bindings.html" class="mobile-nav-chapters previous">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="primitive-types.html" class="mobile-nav-chapters next">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="variable-bindings.html" class="nav-chapters previous">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="primitive-types.html" class="nav-chapters next">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
