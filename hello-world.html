<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title></title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="{% block description %}{% endblock %}">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <!-- Font Awesome -->
        <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="http://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body>
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="introduction.html"><strong>1.</strong> 介绍</a></li><li><ul class="section"><li><a href="installation.html"><strong>1.1.</strong> 安装</a></li><li><a href="hello-world.html" class="active"><strong>1.2.</strong> Hello, World!</a></li><li><a href="design.html"><strong>1.3.</strong> Rust的设计</a></li></ul></li><li><a href="tutorial.html"><strong>2.</strong> Tutorial</a></li><li><a href="primitive-rust.html"><strong>3.</strong> Rust基础</a></li><li><ul class="section"><li><a href="variable-bindings.html"><strong>3.1.</strong> 变量绑定</a></li><li><a href="functions.html"><strong>3.2.</strong> Functions</a></li><li><a href="primitive-types.html"><strong>3.3.</strong> Primitive Types</a></li><li><a href="comments.html"><strong>3.4.</strong> Comments</a></li><li><a href="if.html"><strong>3.5.</strong> `if`</a></li><li><a href="loops.html"><strong>3.6.</strong> Loops</a></li></ul></li><li><a href="ownership-and-borrowing.html"><strong>4.</strong> Ownership & borrowing</a></li><li><ul class="section"><li><a href="ownership.html"><strong>4.1.</strong> Ownership</a></li><li><a href="references-and-borrowing.html"><strong>4.2.</strong> References & Borrowing</a></li><li><a href="lifetimes.html"><strong>4.3.</strong> Lifetimes</a></li></ul></li><li><a href="basic-data-types.html"><strong>5.</strong> Basic Data Types</a></li><li><ul class="section"><li><a href="structs.html"><strong>5.1.</strong> Structs</a></li><li><a href="enums.html"><strong>5.2.</strong> Enums</a></li></ul></li><li><a href="crates-and-modules.html"><strong>6.</strong> Crates & Modules</a></li><li><a href="error-handling.html"><strong>7.</strong> Error Handling</a></li><li><a href="basic-collections.html"><strong>8.</strong> Basic Collections</a></li><li><ul class="section"><li><a href="vectors.html"><strong>8.1.</strong> Vectors</a></li><li><a href="strings.html"><strong>8.2.</strong> Strings</a></li><li><a href="hashmap.html"><strong>8.3.</strong> `HashMap<K, V>`</a></li></ul></li><li><a href="traits.html"><strong>9.</strong> Traits</a></li><li><a href="closures.html"><strong>10.</strong> Closures</a></li><li><a href="iterators.html"><strong>11.</strong> Iterators</a></li><li><a href="io.html"><strong>12.</strong> I/O</a></li><li><ul class="section"><li><a href="read-and-write.html"><strong>12.1.</strong> `Read` & `Write`</a></li><li><a href="fs.html"><strong>12.2.</strong> `std::fs`</a></li><li><a href="path.html"><strong>12.3.</strong> `std::path`</a></li><li><a href="env.html"><strong>12.4.</strong> `std::env`</a></li></ul></li><li><a href="testing.html"><strong>13.</strong> Testing</a></li><li><a href="smart-pointers.html"><strong>14.</strong> Smart Pointers</a></li><li><ul class="section"><li><a href="deref.html"><strong>14.1.</strong> `Deref`</a></li><li><a href="deref-coercions.html"><strong>14.2.</strong> `Deref` coercions</a></li><li><a href="box.html"><strong>14.3.</strong> `Box<T>`</a></li><li><a href="rc.html"><strong>14.4.</strong> `Rc<T>`</a></li></ul></li><li><a href="concurrency.html"><strong>15.</strong> Concurrency</a></li><li><ul class="section"><li><a href="threads.html"><strong>15.1.</strong> Threads</a></li><li><a href="send-and-sync.html"><strong>15.2.</strong> `Send` & `Sync`</a></li><li><a href="arc.html"><strong>15.3.</strong> `Arc<T>`</a></li><li><a href="mutex.html"><strong>15.4.</strong> `Mutex<T>`</a></li><li><a href="channels.html"><strong>15.5.</strong> `Channels`</a></li></ul></li><li><a href="unsafe-rust.html"><strong>16.</strong> Unsafe Rust</a></li><li><ul class="section"><li><a href="raw-pointers.html"><strong>16.1.</strong> Raw Pointers</a></li><li><a href="transmute.html"><strong>16.2.</strong> transmute</a></li></ul></li><li><a href="ffi.html"><strong>17.</strong> FFI</a></li><li><ul class="section"><li><a href="conditional-compilation.html"><strong>17.1.</strong> Conditional Compilation</a></li><li><a href="bindings-to-c.html"><strong>17.2.</strong> Bindings to C</a></li><li><a href="using-rust-from-other-languages.html"><strong>17.3.</strong> Using Rust from Other Languages</a></li><li><a href="static.html"><strong>17.4.</strong> `static`</a></li></ul></li><li><a href="cargo.html"><strong>18.</strong> Cargo</a></li><li><ul class="section"><li><a href="cratesio.html"><strong>18.1.</strong> Crates.io</a></li></ul></li><li><a href="advanced-type-system-features.html"><strong>19.</strong> Advanced Type System Features</a></li><li><ul class="section"><li><a href="associated-types.html"><strong>19.1.</strong> Associated Types</a></li><li><a href="trait-objects.html"><strong>19.2.</strong> Trait Objects</a></li><li><a href="ufcs.html"><strong>19.3.</strong> UFCS</a></li><li><a href="coherence.html"><strong>19.4.</strong> Coherence</a></li></ul></li><li><a href="interior-mutability.html"><strong>20.</strong> Interior mutability</a></li><li><ul class="section"><li><a href="cell.html"><strong>20.1.</strong> `Cell<T>`</a></li><li><a href="refcell.html"><strong>20.2.</strong> `RefCell<T>`</a></li></ul></li><li><a href="macros.html"><strong>21.</strong> Macros</a></li><li><a href="nightly-rust.html"><strong>22.</strong> Nightly Rust</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <h1>Hello, world!</h1>
<p>现在，你已经安装了Rust，让我们开始写第一个Rust程序。
在学习新语言的时候，有一个传统，就是写一个小程序来打印“hello，world！”，在本节，我们将遵循这一传统。</p>
<p>以这样一个简单程序开始的一个好处就是，你可以快速验证编译器是安装好并能正常工作的。
在屏幕上打印信息也是很常见的，所以尽早练习也是件好事。</p>
<blockquote>
<p>注: 本书假设读者已熟悉命令行。
Rust本身并没有具体要求你使用哪种工具、编辑器，所以如果你喜欢用IDE，那也是可以的。</p>
</blockquote>
<h2>创建项目文件</h2>
<p>首先，创建一个文件来写Rust代码。Rust并不关心你的代码在哪，但是对于本书来说，
我的建议是在你的home目录下创建一个 <em>projects</em> 目录，并且把所有的项目都放在里面。
打开终端并且输入下列命令来为这个特别的项目来创建一个目录:</p>
<pre><code class="language-bash">$ mkdir ~/projects
$ cd ~/projects
$ mkdir hello_world
$ cd hello_world
</code></pre>
<blockquote>
<p>注：如果你是在Windows下，并且没有使用PowerShell，那么<code>~</code>将不会工作。
请自行翻阅关于shell更详细的文档。</p>
</blockquote>
<h2>写一个Rust程序并运行</h2>
<p>接下来，创建一个新的源文件，命名为 <em>main.rs</em> 。Rust文件总是以 <em>.rs</em> 扩展名结尾。
如果你的文件名需要以多个单词命名，那么你最好用下划线来分隔这两个单词，
比如，使用 <em>hello_world.rs</em> 来代替 <em>helloworld.rs</em>。</p>
<p>现在，打开你刚刚创建好的 <em>main.rs</em> 文件，并且输入下面代码:</p>
<pre><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre>
<p>保存这个文件，并且返回到终端窗口。在Linux或Mac下，可以输入下面命令:</p>
<pre><code class="language-bash">$ rustc main.rs
$ ./main
Hello, world!
</code></pre>
<p>对于Windows来说，只需要把<code>main</code>换成<code>main.exe</code>。
不管你用哪种操作系统，你应该会看见终端输出Hello，world！字符串。
如果你完成了上述示例，那么恭喜你！
你已经正式写了一个Rust程序，你已经成为一名Rust程序员了！欢迎。</p>
<h2>Rust程序剖析</h2>
<p>现在，让我们来了解一下刚才“Hello，world！”程序的细节。下面是第一部分:</p>
<pre><code class="language-rust">fn main() {

}
</code></pre>
<p>该行代码定义了一个Rust函数。main函数比较特殊：它是每个Rust程序的起点。
第一行的意思是，“我定义来一个名为main的函数，没有参数，也没有返回任何值”。
如果这里有参数，那参数将会放在括号(<code>(</code> 和 <code>)</code>)内，并且因为我们没有从该函数中返回任何值，
我们可以完全忽略返回类型。</p>
<p>也要注意，该函数体是被包裹在大括号 (<code>{</code> 和 <code>}</code>)中的。
Rust要求所有的函数体都必须如此，一个比较好的风格，就是把大括号跟函数声明放在同一行，两者之间隔一个空格。</p>
<p>在<code>main()</code>函数内部:</p>
<pre><code class="language-rust">    println!(&quot;Hello, world!&quot;);
</code></pre>
<p>该行代码在这个小程序中的作用就是： 在屏幕上打印文本。
这里有许多重要的细节，首先，这里（println前面）有四个空格，而非制表符。</p>
<p>第二个重要的部分就是<code>println!()</code>这行。它实际上是调用了一个 <em><a href="macros.html">Rust宏</a>（macro）</em> ，宏是用来实现Rust元编程的。如果直接调用函数而不是宏，则可以写成这样：<code>println()</code>（注意，这里没有”!”）。
我们将在之后讨论Rust宏的更多细节，但是现在你只需要知道，当你看到“叹号（!）”的时候，意味着你调用的是宏，
而非普通函数。</p>
<p>接下来是“Hello，World！”这个 <em>字符串</em> 。
我们把该字符串传作为参数传给<code>println!</code>，此宏负责把字符串打印到屏幕上。就是这么简单！</p>
<p>整行代码以分号（<code>;</code>）结尾。Rust是一个 <em>表达式导向（expression oriented ）</em> 的语言，即Rust里大部分东西都是表达式(expression)，而非语句（statement）。
<code>;</code>表示这个表达式已经结束，并且下一个准备开始。Rust代码中大多数都是以分号(<code>;</code>)结尾。</p>
<h2>编译和运行是独立的两步</h2>
<p>在“写一个Rust程序并运行”小节，我们展示了如何运行一个新创建的程序。我们现在将打破这个过程，来研究每一个步骤。</p>
<p>在运行Rust程序之前，你必须编译它。你能通过输入rustc命令来使用Rust编译器，给它传入一个源文件名即可，像这样:</p>
<pre><code class="language-bash">$ rustc main.rs
</code></pre>
<p>如果你有C或C++背景，你会注意到这和<code>gcc</code>或<code>clang</code>很相似。
在编译成功以后，Rust应该会输出一个二进制可执行文件，在Linux或Mac上，你可以通过ls命令来查看，如下所示:</p>
<pre><code class="language-bash">$ ls
main  main.rs
</code></pre>
<p>在Windows上，你输入:</p>
<pre><code class="language-bash">$ dir
main.exe  main.rs
</code></pre>
<p>这些命令会显示两个文件：使用<code>.rs</code>扩展名的源码文件和可执行文件(Windows上是<code>main.exe</code>，其他是<code>main</code>)。
剩下的事情就是运行<code>mian</code>或<code>main.exe</code>文件了，像这样:</p>
<pre><code class="language-bash">$ ./main  # or main.exe on Windows
</code></pre>
<p>如果 <em>main.rs</em> 是你的“Hello，World！”程序，它将会在你的终端打印“Hello，World！”。</p>
<p>如果你有动态语言的背景，比如用Ruby、Python或JavaScript这些语言，你可能不需要把编译和运行分成独立的两步去做。
Rust是 <em>预编译</em> 语言，也就是说，只要你编译了这个程序，然后把它随便给一个人，他都可以直接运行该程序而不需要安装Rust。
如果你给一个人.rb或.py或.js文件，他们需要分别安装Ruby、Python和JavaScript，但是只需要一个命令就能完成编译和运行该程序。
一切都在于语言设计的权衡。</p>
<p>对于简单的程序来说，只需要用rustc编译就好了，但是当你的项目的增长，你会希望能够管理你项目中所有的选项，
并且可以把它容易的共享给其他人和项目。接下来，我将介绍一个叫做Cargo的工具，它用来帮助我们去写真实世界的Rust程序。</p>
<h1>Hello, Cargo!</h1>
<p>Cargo是Rust的构建（build）系统和包管理器，Rustacean们用Cargo去管理他们的Rust项目。
Fargo管理三件事：构建你的代码、下载你代码依赖的库，以及构建这些库。
我们调用你代码需要“依赖（dependencies）”的库，因为你的代码依赖于它们。</p>
<p>最简单的Rsut程序没有任何依赖，所以现在，你只使用了其功能的第一部分。
当你编写更复杂的Rust程序的时候，你就会添加依赖，如果你使用了Cargo，这一切将会更容易去做。</p>
<p>绝大多数的Rust项目都用Cargo，我们将在本书余下的部分都使用它。如果你用了官方的安装程序，
Cargo是连同Rust一起被安装的。如果你通过其他途径安装Rust，你可以通过在终端输入下面命令来检查Cargo是否被安装:</p>
<pre><code class="language-bash">$ cargo --version
</code></pre>
<p>如果你能看到版本号，那是极好的！如果你看到了像“<code>command not found</code>”这样的错误，
那么你应该看看你安装Rust的那个文档，确定下Cargo是不是分开安装的。</p>
<h2>开始使用Cargo</h2>
<p>让我们把那个Hello World程序换成Cargo的。想Cargo化一个项目，你需要做三件事：</p>
<ol>
<li>把你的源文件放到正确的目录下。</li>
<li>摆脱旧的可执行文件（Windows上的main.exe，其他是main），并且生成一个新的。</li>
<li>创建一个Cargo配置文件。</li>
</ol>
<p>让我们开始吧！</p>
<h3>创建一个新的可执行文件和源目录</h3>
<p>首先，打开你的终端，进入hello_world目录，然后输入下面命令:</p>
<pre><code class="language-bash">$ mkdir src
$ mv main.rs src/main.rs
$ rm main  # or 'del main.exe' on Windows
</code></pre>
<p>Cargo期望你的源文件待在 <em>src</em> 目录里，所以你先得完成这一步。
留在顶级项目目录（在本例中是 <em>hello_world</em> 根目录）中的文件是READMEs、license信息和其他完全和代码无关的文件。
这样一来，使用Cargo可以帮助你保持项目的美丽和整洁。
人神各有层天，各归其位！（There's a place for everything, and everything is in its place.）。</p>
<p>现在，把 <em>main.rs</em> 文件复制到 <em>src</em> 目录中，并且删除你用rustc创建的已编译文件。
跟之前一样，如果你用了Windows，那么就是删除<code>main.exe</code>，其他操作系统是<code>main</code>。</p>
<p>该示例保留了<code>main.rs</code>做为源文件名，因为它创建了可执行文件。
如果你想生成一个库，你需要把文件命名为<code>lib.rs</code>。
Cargo使用这个约定来使编译成功，但是如果你愿意的话也可以重写约定。</p>
<h3>创建配置文件</h3>
<p>接下来，在你的 <em>hello_world</em> 目录中创建一个新的文件，命名为Cargo.toml。</p>
<p>确保Cargo.tom文件名的首字母C是大写，否则Cargo将忽略掉配置文件。</p>
<p>该文件是 <em><a href="https://github.com/toml-lang/toml">TOML</a></em>（Tom’s Obvious,Minimal Language，译者本身也<a href="https://github.com/RustStudy/toml">翻译了TOML的文档</a>，但是pull request一直没被merge，感兴趣的可以去看）格式的。TOML类似于INI，但是有一些其他优点，它被用来作为Cargo的配置文件格式。</p>
<p>在该文件中，输入以下信息:</p>
<pre><code class="language-toml">[package]

name = &quot;hello_world&quot;
version = &quot;0.0.1&quot;
authors = [ &quot;Your name &lt;you@example.com&gt;&quot; ]
</code></pre>
<p>第一行，<code>[package]</code>，表明下面的语句是配置一个包。
当我们在该文件中添加更多信息的时候，我们将添加其他片段，但是现在，我们只有包配置信息片段。</p>
<p>剩下的三行设置了Cargo编译程序时候需要的三部分配置信息：它的名字、它的版本号和它的作者。</p>
<p>一旦你将这些信息添加到 <em>Cargo.toml</em> 文件中并保存之后，那么配置文件也就创建完成了。</p>
<h2>构建并运行一个Cargo项目</h2>
<p>通过项目根目录下的 <em>Cargo.toml</em> 文件，你应该可以构建并运行你的Hello World程序了！输入下列命令来完成它:</p>
<pre><code class="language-bash">$ cargo build
   Compiling hello_world v0.0.1 (file:///home/yourname/projects/hello_world)
$ ./target/debug/hello_world
Hello, world!
</code></pre>
<p>如果一切顺利，你将在终端再次看到<code>Hello，world！</code></p>
<p>你刚才是用<code>cargo build</code>构建了一个项目，并且使用了<code>./target/debug/hello_world</code>运行了它，
但是你实际上可以使用<code>cargo run</code>命令一步完成那两个动作，如下所示:</p>
<pre><code class="language-bash">$ cargo run
     Running `target/debug/hello_world`
Hello, world!
</code></pre>
<p>注意，这个例子并不是重新构建此项目。Cargo发现该文件并没有被改变，所以它只是运行了二进制可执行文件。
如果你修改了你的源代码，Cargo会重写构建项目再运行，你可以会看到类似这样的输出:</p>
<pre><code class="language-bash">$ cargo run
   Compiling hello_world v0.0.1 (file:///home/yourname/projects/hello_world)
     Running `target/debug/hello_world`
Hello, world!
</code></pre>
<p>Cargo知道你项目文件中任何修改，如果最新一次build之后文件有所改变，那么Cargo将会重新构建项目。</p>
<p>对于简单项目来说，Cargo并没有使用到它的诸多功能而只是用了<code>rustc</code>，但是它在以后会非常有用。
对于复杂的项目，用Cargo来协调构建过程会使一切变得更简单。
用Cargo，你可以只运行<code>cargo build</code>，也是它的正确工作方式。</p>
<h2>构建发行版</h2>
<p>当你的项目最终做好了发行的准备，你可以用<code>cargo build —release</code>命令来优化编译你的项目。
这些优化会使你的Rust代码运行的更快，但是换来的代价是你的程序会编译的更慢。
这就是为什么有两个不同的配置文件，一个是为了开发，另一个用于构建你分发给用户的最终版本。</p>
<p>运行该命令也会让Cargo创建一个新的文件，叫 <em>Cargo.lock</em>，看起来像这样:</p>
<pre><code class="language-toml">[root]
name = &quot;hello_world&quot;
version = &quot;0.0.1&quot;
</code></pre>
<p>Cargo使用 <em>Cargo.lock</em> 文件来记录你应用中的依赖。
这是Hello World项目中的 <em>Cargo.lock</em> 文件。
该项目没有任何依赖，所以该文件有点单薄。实际上，你永远不需要亲自接触这个文件，只需要交给Cargo处理就行了。</p>
<p>如果你是从头到尾跟着做的话，你现在应该已经成功使用Cargo构建了hello_world。</p>
<p>尽管该项目很简单，但是它多少也是使用了你以后Rust职业生涯中会用到的真正工具。事实上，你可以认为实际上所有的Rust项目都是使用下面命令的变种:</p>
<pre><code class="language-bash">$ git clone someurl.com/foo
$ cd foo
$ cargo build
</code></pre>
<h2>创建新的Cargo项目最简单的方式</h2>
<p>这是你每次开始一个新项目之前必须要做的过程。Cargo可以快速的生成一个基础项目目录，让你能保持正确的开发姿势。</p>
<p>用Cargo创建新的项目，只需要键入<code>cargo new</code>命令:</p>
<pre><code class="language-bash">$ cargo new hello_world --bin
</code></pre>
<p>该命令传入<code>--bin</code>，是因为我们的目的是直接获取可执行的应用程序，而非一个库。
可执行文件通常被叫做 <em>二进制文件</em>（如果你用了Unix系统，这类文件在/usr/bin目录中）。</p>
<p>Cargo为我们生成了两个文件和一个目录：<em>Cargo.toml</em> 和 <em>src</em> 目录，以及 <em>src</em> 中的 <em>main.rs</em> 文件。
这应该很熟悉了吧，我们在上面的内容中手工创建过。</p>
<p>这便是你开始项目所需要的东西。首先，打开 <em>Cargo.toml</em>。应该能看到跟下面类似的内容:</p>
<pre><code class="language-toml">[package]

name = &quot;hello_world&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]
</code></pre>
<p>Cargo已经根据你给的参数和你的<code>git</code>全局配置自动填充了合适的内容。
你可能也注意到了，Cargo已经把<code>hello_world</code>目录初始化为了<code>git</code>仓库。</p>
<p>在<code>src/main.rs</code>中应该能看到如下内容:</p>
<pre><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre>
<p>Cargo已经为你生成了“hello world！”，你就可以开始coding了！</p>
<blockquote>
<p>注：如果你想了解Cargo更详细的内容，可以去翻阅官方的<a href="http://doc.crates.io/guide.html">Cargo guide</a>，那里覆盖了它所有的特性。</p>
</blockquote>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a href="installation.html" class="mobile-nav-chapters previous">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="design.html" class="mobile-nav-chapters next">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="installation.html" class="nav-chapters previous">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="design.html" class="nav-chapters next">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
