<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title></title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="{% block description %}{% endblock %}">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <!-- Font Awesome -->
        <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="http://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body>
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="introduction.html"><strong>1.</strong> 介绍</a></li><li><ul class="section"><li><a href="installation.html"><strong>1.1.</strong> 安装</a></li><li><a href="hello-world.html"><strong>1.2.</strong> Hello, World!</a></li><li><a href="design.html"><strong>1.3.</strong> Rust的设计</a></li></ul></li><li><a href="tutorial.html"><strong>2.</strong> Tutorial</a></li><li><a href="primitive-rust.html"><strong>3.</strong> Rust基础</a></li><li><ul class="section"><li><a href="variable-bindings.html" class="active"><strong>3.1.</strong> Variable Bindings</a></li><li><a href="functions.html"><strong>3.2.</strong> Functions</a></li><li><a href="primitive-types.html"><strong>3.3.</strong> Primitive Types</a></li><li><a href="comments.html"><strong>3.4.</strong> Comments</a></li><li><a href="if.html"><strong>3.5.</strong> `if`</a></li><li><a href="loops.html"><strong>3.6.</strong> Loops</a></li></ul></li><li><a href="ownership-and-borrowing.html"><strong>4.</strong> Ownership & borrowing</a></li><li><ul class="section"><li><a href="ownership.html"><strong>4.1.</strong> Ownership</a></li><li><a href="references-and-borrowing.html"><strong>4.2.</strong> References & Borrowing</a></li><li><a href="lifetimes.html"><strong>4.3.</strong> Lifetimes</a></li></ul></li><li><a href="basic-data-types.html"><strong>5.</strong> Basic Data Types</a></li><li><ul class="section"><li><a href="structs.html"><strong>5.1.</strong> Structs</a></li><li><a href="enums.html"><strong>5.2.</strong> Enums</a></li></ul></li><li><a href="crates-and-modules.html"><strong>6.</strong> Crates & Modules</a></li><li><a href="error-handling.html"><strong>7.</strong> Error Handling</a></li><li><a href="basic-collections.html"><strong>8.</strong> Basic Collections</a></li><li><ul class="section"><li><a href="vectors.html"><strong>8.1.</strong> Vectors</a></li><li><a href="strings.html"><strong>8.2.</strong> Strings</a></li><li><a href="hashmap.html"><strong>8.3.</strong> `HashMap<K, V>`</a></li></ul></li><li><a href="traits.html"><strong>9.</strong> Traits</a></li><li><a href="closures.html"><strong>10.</strong> Closures</a></li><li><a href="iterators.html"><strong>11.</strong> Iterators</a></li><li><a href="io.html"><strong>12.</strong> I/O</a></li><li><ul class="section"><li><a href="read-and-write.html"><strong>12.1.</strong> `Read` & `Write`</a></li><li><a href="fs.html"><strong>12.2.</strong> `std::fs`</a></li><li><a href="path.html"><strong>12.3.</strong> `std::path`</a></li><li><a href="env.html"><strong>12.4.</strong> `std::env`</a></li></ul></li><li><a href="testing.html"><strong>13.</strong> Testing</a></li><li><a href="smart-pointers.html"><strong>14.</strong> Smart Pointers</a></li><li><ul class="section"><li><a href="deref.html"><strong>14.1.</strong> `Deref`</a></li><li><a href="deref-coercions.html"><strong>14.2.</strong> `Deref` coercions</a></li><li><a href="box.html"><strong>14.3.</strong> `Box<T>`</a></li><li><a href="rc.html"><strong>14.4.</strong> `Rc<T>`</a></li></ul></li><li><a href="concurrency.html"><strong>15.</strong> Concurrency</a></li><li><ul class="section"><li><a href="threads.html"><strong>15.1.</strong> Threads</a></li><li><a href="send-and-sync.html"><strong>15.2.</strong> `Send` & `Sync`</a></li><li><a href="arc.html"><strong>15.3.</strong> `Arc<T>`</a></li><li><a href="mutex.html"><strong>15.4.</strong> `Mutex<T>`</a></li><li><a href="channels.html"><strong>15.5.</strong> `Channels`</a></li></ul></li><li><a href="unsafe-rust.html"><strong>16.</strong> Unsafe Rust</a></li><li><ul class="section"><li><a href="raw-pointers.html"><strong>16.1.</strong> Raw Pointers</a></li><li><a href="transmute.html"><strong>16.2.</strong> transmute</a></li></ul></li><li><a href="ffi.html"><strong>17.</strong> FFI</a></li><li><ul class="section"><li><a href="conditional-compilation.html"><strong>17.1.</strong> Conditional Compilation</a></li><li><a href="bindings-to-c.html"><strong>17.2.</strong> Bindings to C</a></li><li><a href="using-rust-from-other-languages.html"><strong>17.3.</strong> Using Rust from Other Languages</a></li><li><a href="static.html"><strong>17.4.</strong> `static`</a></li></ul></li><li><a href="cargo.html"><strong>18.</strong> Cargo</a></li><li><ul class="section"><li><a href="cratesio.html"><strong>18.1.</strong> Crates.io</a></li></ul></li><li><a href="advanced-type-system-features.html"><strong>19.</strong> Advanced Type System Features</a></li><li><ul class="section"><li><a href="associated-types.html"><strong>19.1.</strong> Associated Types</a></li><li><a href="trait-objects.html"><strong>19.2.</strong> Trait Objects</a></li><li><a href="ufcs.html"><strong>19.3.</strong> UFCS</a></li><li><a href="coherence.html"><strong>19.4.</strong> Coherence</a></li></ul></li><li><a href="interior-mutability.html"><strong>20.</strong> Interior mutability</a></li><li><ul class="section"><li><a href="cell.html"><strong>20.1.</strong> `Cell<T>`</a></li><li><a href="refcell.html"><strong>20.2.</strong> `RefCell<T>`</a></li></ul></li><li><a href="macros.html"><strong>21.</strong> Macros</a></li><li><a href="nightly-rust.html"><strong>22.</strong> Nightly Rust</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <h1>变量绑定（Variable Bindings）</h1>
<p>几乎每个程序的基本能力是存储和修改数据。
Rust也不例外。
让我们以一个简单示例开始。</p>
<h2>绑定（binding）的基础知识</h2>
<p>首先，我们将使用Cargo生成一个新的项目。
打开终端，并定位到你想保存项目的目录。在那里，让我们生成一个新的项目:</p>
<pre><code class="language-bash">$ cargo new --bin bindings
$ cd bindings
</code></pre>
<p>这会创建一个新的项目，'bindings'，并且会建立我们的<code>Cargo.toml</code>和<code>src/main.rs</code>文件。
我们在&quot;Hello, World!&quot;章节中见过，Cargo会生成这些文件，并且为我们创建一个‘hello world’程序:</p>
<pre><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre>
<p>让我们用这个程序覆盖上面那个:</p>
<pre><code class="language-rust">fn main() {
    let x = 5;

    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre>
<p>并运行它:</p>
<pre><code class="language-bash">$ cargo run
   Compiling bindings v0.1.0 (file:///home/steve/tmp/bindings)
     Running `target/debug/bindings`
The value of x is: 5
</code></pre>
<p>如果你看到的是错误信息，请仔细检查你有没有复制正确上面的代码。
让我们一行一行来解读。</p>
<pre><code class="language-rust,ignore">fn main() {
</code></pre>
<p><code>main()</code>函数是每个Rust程序的入口。
我们在下节会讲更多关于函数（function）的内容，但是现在，我们只需要知道程序从哪里开始就够了。
开头的大括号<code>{</code>，表示函数体的开始。</p>
<pre><code class="language-rust,ignore">    let x = 5;
</code></pre>
<p>这是我们第一个‘变量绑定’，它是我们用‘<code>let</code>语句（statement）’创建的。</p>
<p>这个<code>let</code>语句格式是这样的:</p>
<pre><code class="language-text">let NAME = EXPRESSION;
</code></pre>
<p>一个<code>let</code>语句首先会对<code>EXPRESSION</code>进行求值，然后把结果值绑定给<code>NAME</code>，以便它能在后面的程序中被引用。
在我们这个简单示例中，表达式已经是一个值了，是5，但是我们能实现相同的效果:</p>
<pre><code class="language-rust">let x = 2 + 3;
</code></pre>
<p>一般情况下，<code>let</code>语句跟模式（pattern）一起工作，变量名只是模式的一种简单形式。
模式，是Rust的重要组成部分，我们将在后面看到更复杂更强大的模式。</p>
<p>在这样做之前，我们先来把这个例子的剩余部分弄清楚。
来看下一行:</p>
<pre><code class="language-rust,ignore">    println!(&quot;The value of x is: {}&quot;, x);
</code></pre>
<p><code>println!</code>宏在屏幕上打印文本。
我们可以告诉大家，这是一个宏，因为那个<code>!</code>。
我们不会学习如何编写宏，你将在本书的后面学到，但是我们会用到由整个标准库提供的宏。
每次你看到<code>!</code>，请记住，这意味着一个宏。
宏可以为语言增加新的语法，并且<code>!</code>意味着提醒某件事非比寻常。</p>
<p><code>println!</code>，具体来说，有一个必须的参数，‘格式字符串（format string）’，以及任意个数的可选参数。
格式字符串可以包含特殊的文本<code>{}</code>。
每个<code>{}</code>都对应一个额外的参数。这里有一个例子:</p>
<pre><code class="language-rust">let x = 2 + 3;
let y = x + 5;
println!(&quot;The value of x is {}, and the value of y is {}&quot;, x, y);
</code></pre>
<p>你可以想象<code>{}</code>是一个固定了值的小蟹钳。
这样的占位符有很多高级的格式选项，我们将在后面讨论。</p>
<pre><code class="language-rust,ignore">}
</code></pre>
<p>最后，一个闭合大括号匹配了该<code>main()</code>函数声明的起始大括号，函数声明结束。</p>
<p>对于输出:</p>
<pre><code class="language-text">The value of x is: 5
</code></pre>
<p>我们将<code>5</code>绑定给<code>x</code>，然后用<code>println!</code>将其打印到屏幕上。</p>
<p>We assign <code>5</code> to a binding, <code>x</code>, and then print it to the screen with <code>println!</code>.</p>
<h2>多个绑定</h2>
<p>让我们尝试一个更复杂的模式。
对我们的示例做如下改变:</p>
<pre><code class="language-rust">fn main() {
    let (x, y) = (5, 6);

    println!(&quot;The value of x is: {}&quot;, x);
    println!(&quot;The value of y is: {}&quot;, y);
}
</code></pre>
<p>使用<code>cargo run</code>运行它:</p>
<pre><code class="language-text">$ cargo run
   Compiling bindings v0.1.0 (file:///home/steve/tmp/bindings)
     Running `target/debug/bindings`
The value of x is: 5
The value of y is: 6
</code></pre>
<p>我们用一个<code>let</code>创建了两个绑定！
这里是我们的模式:</p>
<pre><code class="language-text">(x, y)
</code></pre>
<p>这是值:</p>
<pre><code class="language-text">(5, 6)
</code></pre>
<p>如你所见，上面的两行是让<code>x</code>绑定<code>5</code>，<code>y</code>绑定<code>6</code>。
我们也能用两个<code>let</code>语句:</p>
<pre><code class="language-rust">fn main() {
    let x = 5;
    let y = 6;
}
</code></pre>
<p>对于像这样简单的情况来说，两个<code>let</code>也许更清晰，但是其他情况，一次创建多个绑定也许更好。
当我们变得越来越精通Rust，我们就会找出哪种风格更好，但是它最多是个主观判断。</p>
<h2>类型注解（type annotation）</h2>
<p>你可能已经注意到了，在前一个例子中，我们并没有声明<code>x</code>或<code>y</code>的类型。
Rust是一个 *静态类型（statically typed）*语言，也就是说，在编译时，我们必须知道所有绑定的类型。
但是注解每一个绑定的类型是个繁杂的工作，并且会让代码变的嘈杂。
为了解决这个问题，Rust使用了‘类型推导（type inference）’，即，它会尝试推断绑定的类型。</p>
<p>类型推导的主要方式是通过查看它是如何被用的。
让我们再次查看示例:</p>
<pre><code class="language-rust">fn main() {
    let x = 5;
}
</code></pre>
<p>当我们把<code>5</code>绑定给<code>x</code>的时候，编译器知道<code>x</code>应该是一个数值类型。
在没有其他任何信息的情况下，它默认是<code>i32</code>类型，32位整数类型。
我们将在3.3节讨论更多关于Rust的基本类型。</p>
<p>下面是使用了<code>类型注解</code>的<code>let</code>语句示例:</p>
<pre><code class="language-rust">fn main() {
    let x: i32 = 5;
}
</code></pre>
<p>我们可以添加一个冒号，然后是类型名称。
这里是使用了类型注解的<code>let</code>语句结构:</p>
<pre><code class="language-text">let PATTERN: TYPE = VALUE;
</code></pre>
<p>注意，冒号和<code>TYPE</code>在<code>PATTERN</code>后面。
这里有使用了两个绑定的复杂模式:</p>
<pre><code class="language-rust">fn main() {
    let (x, y): (i32, i32) = (5, 6);
}
</code></pre>
<p>就像我们用<code>PATTERN</code>匹配<code>VALUE</code>那样，我们也用<code>PATTERN</code>匹配<code>TYPE</code>。</p>
<h2>延迟初始化（Delayed Initialization）</h2>
<p>绑定的初始值不是必须提供的，我们可以在之后再把值指派给它。试试这段代码:</p>
<pre><code class="language-rust">fn main() {
    let x;

    x = 5;

    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre>
<p>使用<code>cargo run</code>执行:</p>
<pre><code class="language-text">$ cargo run
   Compiling bindings v0.1.0 (file:///home/steve/tmp/bindings)
     Running `target/debug/bindings`
The value of x is: 5
</code></pre>
<p>执行的很顺利。
这就是引出一个问题: 如果我们在声明一个值之前尝试打印绑定会怎么样？
下面是演示此问题的代码:</p>
<pre><code class="language-rust,ignore">fn main() {
    let x;

    println!(&quot;The value of x is: {}&quot;, x);

    x = 5;
}
</code></pre>
<p>我们可以通过执行<code>cargo run</code>找出答案:</p>
<pre><code class="language-text">   Compiling bindings v0.1.0 (file:///home/steve/tmp/bindings)
src/main.rs:4:39: 4:40 error: use of possibly uninitialized variable: `x` [E0381]
src/main.rs:4     println!(“The value of x is: {}”, x);
                                                    ^
&lt;std macros&gt;:2:25: 2:56 note: in this expansion of format_args!
&lt;std macros&gt;:3:1: 3:54 note: in this expansion of print! (defined in &lt;std macros&gt;)
src/main.rs:4:5: 4:42 note: in this expansion of println! (defined in &lt;std macros&gt;)
src/main.rs:4:39: 4:40 help: run `rustc --explain E0381` to see a detailed explanation
error: aborting due to previous error
Could not compile `bindings`.

To learn more, run the command again with --verbose.
</code></pre>
<p>一个错误！
编译器不让我们这样去写程序。
这是编译器帮助我们在程序中发现错误的第一个示例。
不同的程序语言对这个问题的处理方法不同。
有些语言总是会初始化某种默认值。
另外一些语言会留着未初始化的值，而不保证你在初始化它之前用到它的时候会出现什么么蛾子。
Rust选择了另外一种: 抛出错误，并且强制要求程序员去说清楚他们到底想做什么。
我们在用<code>x</code>之前，必须初始化某种值。</p>
<h3>扩展错误解释</h3>
<p>这有关于错误消息更有趣的部分:</p>
<pre><code class="language-text">src/main.rs:4:39: 4:40 help: run `rustc --explain E0381` to see a detailed explanation
</code></pre>
<p>我们通过给<code>rustc</code>传入<code>--explain</code>就能看到扩展的错误解释。
并不是每个错误都有更详细的解释，但是大部分是如此。
这些扩展的解释试图展示错误发生的常见原因，以及问题的常见解决方案。</p>
<p>下面是<code>E0381</code>:</p>
<pre><code class="language-bash">$ rustc --explain E0381
It is not allowed to use or capture an uninitialized variable. For example:

fn main() {
    let x: i32;
    let y = x; // error, use of possibly uninitialized variable

To fix this, ensure that any declared variables are initialized before being
used.
</code></pre>
<p>如果你对某个错误束手无策的话，这些解释可以帮到你。
编译器是你的朋友，并为你提供帮助。</p>
<h2>可变绑定</h2>
<p>改变绑定的值会怎么样？ 这里有另外一个示例展示了这个问题:</p>
<pre><code class="language-rust,ignore">fn main() {
    let x = 5;

    x = 6;

    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre>
<p><code>cargo run</code>为我们给出了答案:</p>
<pre><code class="language-bash">$ cargo run
   Compiling bindings v0.1.0 (file:///home/steve/tmp/bindings)
src/main.rs:4:5: 4:10 error: re-assignment of immutable variable `x` [E0384]
src/main.rs:4     x = 6;
                  ^~~~~
src/main.rs:4:5: 4:10 help: run `rustc --explain E0384` to see a detailed explanation
src/main.rs:2:9: 2:10 note: prior assignment occurs here
src/main.rs:2     let x = 5;
                      ^
</code></pre>
<p>错误里提到<code>re-assigment of immutable variable</code>（重新指派不可变变量）
这是对的: 绑定是不可变的.
但是仅仅是指它们默认不可变。
当我们创建新绑定的时候，我们可以在模式（译注：x = 5，叫模式）前面增加<code>mut</code>来把绑定变成可变的。
这有个例子:</p>
<pre><code class="language-rust">fn main() {
    let mut x = 5;

    println!(&quot;The value of x is: {}&quot;, x);

    x = 6;

    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre>
<p>运行它:</p>
<pre><code class="language-bash">$ cargo run
   Compiling bindings v0.1.0 (file:///home/steve/tmp/bindings)
     Running `target/debug/bindings`
The value of x is: 5
The value of x is: 6
</code></pre>
<p>我们现在可以改变<code>x</code>绑定的值了。
注意该语法<code>let mut</code>不是一体的，而是在模式前使用了<code>mut</code>
对模式使用<code>()</code>更明显:</p>
<pre><code class="language-rust,ignore">fn main() {
    let (mut x, y) = (5, 6);

    x = 7;
    y = 8;
}
</code></pre>
<p>编译器会对这段程序发牢骚:</p>
<pre><code class="language-bash">$ cargo build
   Compiling bindings v0.1.0 (file:///home/steve/tmp/bindings)
src/main.rs:5:5: 5:10 error: re-assignment of immutable variable `y` [E0384]
src/main.rs:5     y = 8;
                  ^~~~~
src/main.rs:5:5: 5:10 help: run `rustc --explain E0384` to see a detailed explanation
src/main.rs:2:17: 2:18 note: prior assignment occurs here
src/main.rs:2     let (mut x, y) = (5, 6);
                              ^
</code></pre>
<p>重新指派<code>x</code>是可以的，但是<code>y</code>却不行。
<code>mut</code>仅对就近的绑定起作用，而不是整个模式。</p>
<h3>重新指派，而不是变化</h3>
<p>还有个细微之处，我们还没有讨论过: <code>mut</code>允许你去改变_绑定_，而不是改变_绑定的值_。
换句话说:</p>
<pre><code class="language-rust">fn main() {
    let mut x = 5;

    x = 6;
}
</code></pre>
<p>这不会改变<code>x</code>绑定的值，而是创建了一个新值，<code>6</code>，然后让<code>x</code>绑定了新值。
这是一个微妙但很重要的区别。
现在并没有太大差别，但是当我们的程序变得更复杂的时候，差异就会明显。
特别是，当给函数传递参数的时候，差异将显现。
我们将在下一节讨论函数的时候来探讨这种差别。</p>
<h2>作用域（scope）</h2>
<p>变量绑定有其生效的‘作用域’。
作用域起始于绑定的声明，结束于下一个代码块。
我们仅能在‘作用域中’访问到绑定。
在“进入作用域之前”和“离开作用域之后”都不能访问绑定。
这里是一个示例:</p>
<pre><code class="language-rust">fn main() {
    println!(&quot;x is not yet in scope&quot;);

    let x = 5;
    println!(&quot;x is now in scope&quot;);

    println!(&quot;In real code, we’d now do a bunch of work.&quot;);

    println!(&quot;x will go out of scope now! The next curly brace is ending the main function.&quot;);
}
</code></pre>
<p>我们可以通过使用<code>{</code>和<code>}</code>创建任意作用域:</p>
<pre><code class="language-rust">fn main() {
    println!(&quot;x is not yet in scope&quot;);

    let x = 5;
    println!(&quot;x is now in scope&quot;);

    println!(&quot;Let’s start a new scope!&quot;);

    {
        let y = 5;
        println!(&quot;y is now in scope&quot;);
        println!(&quot;x is also still in scope&quot;);

        println!(&quot;y will go out of scope now!&quot;);
        println!(&quot;The next curly brace is ending the scope we started.&quot;);
    }

    println!(&quot;x is still in scope, but y is now out of scope and is not usable&quot;);

    println!(&quot;x will go out of scope now! The next curly brace is ending the main function.&quot;);
}
</code></pre>
<p>一旦我们学习了关于<code>引用（reference）</code>和<code>特质（trait）</code>之后，绑定是在作用域内还是作用域外，将会变的更加重要。</p>
<h2>绑定屏蔽（Shadowing）</h2>
<p>关于绑定的最后一件事是: 它们可以用相同的名称‘屏蔽（shadow）’前一个绑定。
这里是一个简单示例:</p>
<pre><code class="language-rust">fn main() {
    let x = 5;
    let x = 6;

    println!(&quot;The value of x is: {}&quot;, x);
}  
</code></pre>
<p>运行它，我们能看到屏蔽起作用了:</p>
<pre><code class="language-text">src/main.rs:2:9: 2:10 warning: unused variable: `x`, #[warn(unused_variables)] on by default
src/main.rs:2     let x = 5;
                      ^
     Running `target/debug/bindings`
The value of x is: 6
</code></pre>
<p>在此输出中有两件有意思的事。
首先，Rust能编译并运行这段程序，没有问题。
其次，如我们所见，<code>x</code>的值是<code>6</code>。
但是，我们没有把<code>x</code>声明为可变绑定。
而是声明了一个_新_的绑定，也把它命名为<code>x</code>，然后指派给它一个新值。
只要新的<code>x</code>被声明，旧的<code>x</code>绑定的值就无法被访问了。
如果你想改变一个值，但是又想让它不可变，那可以用绑定屏蔽。
比如:</p>
<pre><code class="language-rust">fn main() {
    let x = 5;
    let x = x + 1;
    let x = x * 2;

    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre>
<p>将会输出:</p>
<pre><code class="language-bash">   Compiling bindings v0.1.0 (file:///home/steve/tmp/bindings)
     Running `target/debug/bindings`
The value of x is: 12
</code></pre>
<p>这让我们修改<code>x</code>，但没有把绑定改成可变的。
这样做是有好处的，因为后面如果我们修改它的话，编译器会提示我们的。
假设我们计算出<code>12</code>以后，还想修改<code>x</code>。
如果没把程序改成可变绑定的风格，大概是这样:</p>
<pre><code>fn main() {
    let mut x = 5;
    x = x + 1;
    x = x * 2;

    println!(&quot;The value of x is: {}&quot;, x);

    x = 15;

    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre>
<p>Rust很乐意让我们再次修改它为<code>15</code>。
把上面程序改成不可变风格以后，再去修改<code>x</code>:</p>
<pre><code class="language-rust,ignore">fn main() {
    let x = 5;
    let x = x + 1;
    let x = x * 2;

    println!(&quot;The value of x is: {}&quot;, x);

    x = 15;

    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre>
<p>如果我们尝试编译，会得到下面错误:</p>
<pre><code class="language-bash">$ cargo build
   Compiling bindings v0.1.0 (file:///home/steve/tmp/bindings)
src/main.rs:8:5: 8:11 error: re-assignment of immutable variable `x` [E0384]
src/main.rs:8     x = 15;
                  ^~~~~~
src/main.rs:8:5: 8:11 help: run `rustc --explain E0384` to see a detailed explanation
src/main.rs:4:9: 4:10 note: prior assignment occurs here
src/main.rs:4     let x = x * 2;
                      ^
error: aborting due to previous error
Could not compile `bindings`.
</code></pre>
<p>正是我们想要的。</p>
<p>绑定屏蔽可能需要一些时间来适应，但是它非常强大，并且可以和不可变风格的代码很配。</p>
<p>我们讨论一下关于在本节最初那个程序编译输出的问题。
这是其中一部分:</p>
<pre><code class="language-text">src/main.rs:2:9: 2:10 warning: unused variable: `x`, #[warn(unused_variables)] on by default
</code></pre>
<p>下面是两行相关的代码:</p>
<pre><code class="language-rust">let x = 5;
let x = 6;
</code></pre>
<p>Rust知道我们屏蔽了绑定<code>x</code>，但是我们从始至终都没有用到过初始值。
这不是个错误，确切来说，它可能不是我们想要的结果。
在这种情况下，编译器发出了一个‘警告’，但是仍然会编译我们的程序。
<code>#[warn(unused_variables)]</code> 语法被叫做‘属性（attribute）’，我们将在后面的章节讨论。
更具体来讲，这样的警告被称为'lint'，它是一个古老术语，是对那些你不想编入布里的羊毛的称呼。
代码里这行lint很相似，它告诉我们，这里可能有一些并不需要的多余代码。
没有它，我们的代码也会工作的很好。
这些警告值得注意，并要根据它们的提示修复这些问题。
因为它们可能是某种严重问题的信号。
在本例中，我可能没有意识到我们已经屏蔽了绑定<code>x</code>。</p>
<h3>绑定屏蔽和作用域</h3>
<p>跟任意绑定一样，一个绑定屏蔽另外一个绑定也是只在作用域内有效。
这里是示例代码:</p>
<pre><code class="language-rust">fn main() {
    let x = 5;

    println!(&quot;Before shadowing, x is: {}&quot;, x);

    {
        let x = 6;

        println!(&quot;Now that x is shadowed, x is: {}&quot;, x);
    }

    println!(&quot;After shadowing, x is: {}&quot;, x);
}
</code></pre>
<p>如果我们运行这个程序，我们能看到“屏蔽绑定”的变化:</p>
<pre><code class="language-bash">$ cargo run
   Compiling bindings v0.1.0 (file:///home/steve/tmp/bindings)
     Running `target/debug/bindings`
Before shadowing, x is: 5
Now that x is shadowed, x is: 6
After shadowing, x is: 5
</code></pre>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a href="primitive-rust.html" class="mobile-nav-chapters previous">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="functions.html" class="mobile-nav-chapters next">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="primitive-rust.html" class="nav-chapters previous">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="functions.html" class="nav-chapters next">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
