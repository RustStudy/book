<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title></title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="{% block description %}{% endblock %}">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <!-- Font Awesome -->
        <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="http://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body>
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="introduction.html"><strong>1.</strong> 介绍</a></li><li><ul class="section"><li><a href="installation.html"><strong>1.1.</strong> 安装</a></li><li><a href="hello-world.html"><strong>1.2.</strong> Hello, World!</a></li><li><a href="design.html"><strong>1.3.</strong> Rust的设计</a></li></ul></li><li><a href="tutorial.html"><strong>2.</strong> Tutorial</a></li><li><a href="primitive-rust.html"><strong>3.</strong> Rust基础</a></li><li><ul class="section"><li><a href="variable-bindings.html"><strong>3.1.</strong> 变量绑定</a></li><li><a href="functions.html"><strong>3.2.</strong> Functions</a></li><li><a href="primitive-types.html"><strong>3.3.</strong> Primitive Types</a></li><li><a href="comments.html"><strong>3.4.</strong> Comments</a></li><li><a href="if.html"><strong>3.5.</strong> `if`</a></li><li><a href="loops.html"><strong>3.6.</strong> Loops</a></li></ul></li><li><a href="ownership-and-borrowing.html"><strong>4.</strong> Ownership & borrowing</a></li><li><ul class="section"><li><a href="ownership.html" class="active"><strong>4.1.</strong> Ownership</a></li><li><a href="references-and-borrowing.html"><strong>4.2.</strong> References & Borrowing</a></li><li><a href="lifetimes.html"><strong>4.3.</strong> Lifetimes</a></li></ul></li><li><a href="basic-data-types.html"><strong>5.</strong> Basic Data Types</a></li><li><ul class="section"><li><a href="structs.html"><strong>5.1.</strong> Structs</a></li><li><a href="enums.html"><strong>5.2.</strong> Enums</a></li></ul></li><li><a href="crates-and-modules.html"><strong>6.</strong> Crates & Modules</a></li><li><a href="error-handling.html"><strong>7.</strong> Error Handling</a></li><li><a href="basic-collections.html"><strong>8.</strong> Basic Collections</a></li><li><ul class="section"><li><a href="vectors.html"><strong>8.1.</strong> Vectors</a></li><li><a href="strings.html"><strong>8.2.</strong> Strings</a></li><li><a href="hashmap.html"><strong>8.3.</strong> `HashMap<K, V>`</a></li></ul></li><li><a href="traits.html"><strong>9.</strong> Traits</a></li><li><a href="closures.html"><strong>10.</strong> Closures</a></li><li><a href="iterators.html"><strong>11.</strong> Iterators</a></li><li><a href="io.html"><strong>12.</strong> I/O</a></li><li><ul class="section"><li><a href="read-and-write.html"><strong>12.1.</strong> `Read` & `Write`</a></li><li><a href="fs.html"><strong>12.2.</strong> `std::fs`</a></li><li><a href="path.html"><strong>12.3.</strong> `std::path`</a></li><li><a href="env.html"><strong>12.4.</strong> `std::env`</a></li></ul></li><li><a href="testing.html"><strong>13.</strong> Testing</a></li><li><a href="smart-pointers.html"><strong>14.</strong> Smart Pointers</a></li><li><ul class="section"><li><a href="deref.html"><strong>14.1.</strong> `Deref`</a></li><li><a href="deref-coercions.html"><strong>14.2.</strong> `Deref` coercions</a></li><li><a href="box.html"><strong>14.3.</strong> `Box<T>`</a></li><li><a href="rc.html"><strong>14.4.</strong> `Rc<T>`</a></li></ul></li><li><a href="concurrency.html"><strong>15.</strong> Concurrency</a></li><li><ul class="section"><li><a href="threads.html"><strong>15.1.</strong> Threads</a></li><li><a href="send-and-sync.html"><strong>15.2.</strong> `Send` & `Sync`</a></li><li><a href="arc.html"><strong>15.3.</strong> `Arc<T>`</a></li><li><a href="mutex.html"><strong>15.4.</strong> `Mutex<T>`</a></li><li><a href="channels.html"><strong>15.5.</strong> `Channels`</a></li></ul></li><li><a href="unsafe-rust.html"><strong>16.</strong> Unsafe Rust</a></li><li><ul class="section"><li><a href="raw-pointers.html"><strong>16.1.</strong> Raw Pointers</a></li><li><a href="transmute.html"><strong>16.2.</strong> transmute</a></li></ul></li><li><a href="ffi.html"><strong>17.</strong> FFI</a></li><li><ul class="section"><li><a href="conditional-compilation.html"><strong>17.1.</strong> Conditional Compilation</a></li><li><a href="bindings-to-c.html"><strong>17.2.</strong> Bindings to C</a></li><li><a href="using-rust-from-other-languages.html"><strong>17.3.</strong> Using Rust from Other Languages</a></li><li><a href="static.html"><strong>17.4.</strong> `static`</a></li></ul></li><li><a href="cargo.html"><strong>18.</strong> Cargo</a></li><li><ul class="section"><li><a href="cratesio.html"><strong>18.1.</strong> Crates.io</a></li></ul></li><li><a href="advanced-type-system-features.html"><strong>19.</strong> Advanced Type System Features</a></li><li><ul class="section"><li><a href="associated-types.html"><strong>19.1.</strong> Associated Types</a></li><li><a href="trait-objects.html"><strong>19.2.</strong> Trait Objects</a></li><li><a href="ufcs.html"><strong>19.3.</strong> UFCS</a></li><li><a href="coherence.html"><strong>19.4.</strong> Coherence</a></li></ul></li><li><a href="interior-mutability.html"><strong>20.</strong> Interior mutability</a></li><li><ul class="section"><li><a href="cell.html"><strong>20.1.</strong> `Cell<T>`</a></li><li><a href="refcell.html"><strong>20.2.</strong> `RefCell<T>`</a></li></ul></li><li><a href="macros.html"><strong>21.</strong> Macros</a></li><li><a href="nightly-rust.html"><strong>22.</strong> Nightly Rust</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <h1>Ownership</h1>
<p>This guide is one of three presenting Rust’s ownership system. This is one of
Rust’s most unique and compelling features, with which Rust developers should
become quite acquainted. Ownership is how Rust achieves its largest goal,
memory safety. There are a few distinct concepts, each with its own
chapter:</p>
<ul>
<li>ownership, which you’re reading now</li>
<li><a href="references-and-borrowing.html">borrowing</a>, and their associated feature ‘references’</li>
<li><a href="lifetimes.html">lifetimes</a>, an advanced concept of borrowing</li>
</ul>
<p>These three chapters are related, and in order. You’ll need all three to fully
understand the ownership system.</p>
<h1>Meta</h1>
<p>Before we get to the details, two important notes about the ownership system.</p>
<p>Rust has a focus on safety and speed. It accomplishes these goals through many
‘zero-cost abstractions’, which means that in Rust, abstractions cost as little
as possible in order to make them work. The ownership system is a prime example
of a zero-cost abstraction. All of the analysis we’ll talk about in this guide
is <em>done at compile time</em>. You do not pay any run-time cost for any of these
features.</p>
<p>However, this system does have a certain cost: learning curve. Many new users
to Rust experience something we like to call ‘fighting with the borrow
checker’, where the Rust compiler refuses to compile a program that the author
thinks is valid. This often happens because the programmer’s mental model of
how ownership should work doesn’t match the actual rules that Rust implements.
You probably will experience similar things at first. There is good news,
however: more experienced Rust developers report that once they work with the
rules of the ownership system for a period of time, they fight the borrow
checker less and less.</p>
<p>With that in mind, let’s learn about ownership.</p>
<h1>Ownership</h1>
<p><a href="variable-bindings.html">Variable bindings</a> have a property in Rust: they ‘have ownership’
of what they’re bound to. This means that when a binding goes out of scope,
Rust will free the bound resources. For example:</p>
<pre><code class="language-rust">fn foo() {
    let v = vec![1, 2, 3];
}
</code></pre>
<p>When <code>v</code> comes into scope, a new [<code>Vec&lt;T&gt;</code>]<a href="../std/vec/struct.Vec.html">vect</a> is created. In this case, the
vector also allocates space on <a href="the-stack-and-the-heap.html">the heap</a>, for the three elements. When
<code>v</code> goes out of scope at the end of <code>foo()</code>, Rust will clean up everything
related to the vector, even the heap-allocated memory. This happens
deterministically, at the end of the scope.</p>
<h1>Move semantics</h1>
<p>There’s some more subtlety here, though: Rust ensures that there is <em>exactly
one</em> binding to any given resource. For example, if we have a vector, we can
assign it to another binding:</p>
<pre><code class="language-rust">let v = vec![1, 2, 3];

let v2 = v;
</code></pre>
<p>But, if we try to use <code>v</code> afterwards, we get an error:</p>
<pre><code class="language-rust,ignore">let v = vec![1, 2, 3];

let v2 = v;

println!(&quot;v[0] is: {}&quot;, v[0]);
</code></pre>
<p>It looks like this:</p>
<pre><code class="language-text">error: use of moved value: `v`
println!(&quot;v[0] is: {}&quot;, v[0]);
                        ^
</code></pre>
<p>A similar thing happens if we define a function which takes ownership, and
try to use something after we’ve passed it as an argument:</p>
<pre><code class="language-rust,ignore">fn take(v: Vec&lt;i32&gt;) {
    // what happens here isn’t important.
}

let v = vec![1, 2, 3];

take(v);

println!(&quot;v[0] is: {}&quot;, v[0]);
</code></pre>
<p>Same error: ‘use of moved value’. When we transfer ownership to something else,
we say that we’ve ‘moved’ the thing we refer to. You don’t need some sort of
special annotation here, it’s the default thing that Rust does.</p>
<h2>The details</h2>
<p>The reason that we cannot use a binding after we’ve moved it is subtle, but
important. When we write code like this:</p>
<pre><code class="language-rust">let v = vec![1, 2, 3];

let v2 = v;
</code></pre>
<p>The first line allocates memory for the vector object, <code>v</code>, and for the data it
contains. The vector object is stored on the <a href="the-stack-and-the-heap.html">stack</a> and contains a pointer
to the content (<code>[1, 2, 3]</code>) stored on the <a href="the-stack-and-the-heap.html">heap</a>. When we move <code>v</code> to <code>v2</code>,
it creates a copy of that pointer, for <code>v2</code>. Which means that there would be two
pointers to the content of the vector on the heap. It would violate Rust’s
safety guarantees by introducing a data race. Therefore, Rust forbids using <code>v</code>
after we’ve done the move.</p>
<p>It’s also important to note that optimizations may remove the actual copy of
the bytes on the stack, depending on circumstances. So it may not be as
inefficient as it initially seems.</p>
<h2><code>Copy</code> types</h2>
<p>We’ve established that when ownership is transferred to another binding, you
cannot use the original binding. However, there’s a <a href="traits.html">trait</a> that changes this
behavior, and it’s called <code>Copy</code>. We haven’t discussed traits yet, but for now,
you can think of them as an annotation to a particular type that adds extra
behavior. For example:</p>
<pre><code class="language-rust">let v = 1;

let v2 = v;

println!(&quot;v is: {}&quot;, v);
</code></pre>
<p>In this case, <code>v</code> is an <code>i32</code>, which implements the <code>Copy</code> trait. This means
that, just like a move, when we assign <code>v</code> to <code>v2</code>, a copy of the data is made.
But, unlike a move, we can still use <code>v</code> afterward. This is because an <code>i32</code>
has no pointers to data somewhere else, copying it is a full copy.</p>
<p>All primitive types implement the <code>Copy</code> trait and their ownership is
therefore not moved like one would assume, following the ´ownership rules´.
To give an example, the two following snippets of code only compile because the
<code>i32</code> and <code>bool</code> types implement the <code>Copy</code> trait.</p>
<pre><code class="language-rust">fn main() {
    let a = 5;

    let _y = double(a);
    println!(&quot;{}&quot;, a);
}

fn double(x: i32) -&gt; i32 {
    x * 2
}
</code></pre>
<pre><code class="language-rust">fn main() {
    let a = true;

    let _y = change_truth(a);
    println!(&quot;{}&quot;, a);
}

fn change_truth(x: bool) -&gt; bool {
    !x
}
</code></pre>
<p>If we had used types that do not implement the <code>Copy</code> trait,
we would have gotten a compile error because we tried to use a moved value.</p>
<pre><code class="language-text">error: use of moved value: `a`
println!(&quot;{}&quot;, a);
               ^
</code></pre>
<p>We will discuss how to make your own types <code>Copy</code> in the <a href="traits.html">traits</a>
section.</p>
<h1>More than ownership</h1>
<p>Of course, if we had to hand ownership back with every function we wrote:</p>
<pre><code class="language-rust">fn foo(v: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {
    // do stuff with v

    // hand back ownership
    v
}
</code></pre>
<p>This would get very tedious. It gets worse the more things we want to take ownership of:</p>
<pre><code class="language-rust">fn foo(v1: Vec&lt;i32&gt;, v2: Vec&lt;i32&gt;) -&gt; (Vec&lt;i32&gt;, Vec&lt;i32&gt;, i32) {
    // do stuff with v1 and v2

    // hand back ownership, and the result of our function
    (v1, v2, 42)
}

let v1 = vec![1, 2, 3];
let v2 = vec![1, 2, 3];

let (v1, v2, answer) = foo(v1, v2);
</code></pre>
<p>Ugh! The return type, return line, and calling the function gets way more
complicated.</p>
<p>Luckily, Rust offers a feature, borrowing, which helps us solve this problem.
It’s the topic of the next section!</p>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a href="ownership-and-borrowing.html" class="mobile-nav-chapters previous">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="references-and-borrowing.html" class="mobile-nav-chapters next">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="ownership-and-borrowing.html" class="nav-chapters previous">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="references-and-borrowing.html" class="nav-chapters next">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
